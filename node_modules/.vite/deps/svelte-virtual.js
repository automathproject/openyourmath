import "./chunk-AYNHEKRI.js";
import {
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  compute_slots,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  outro_and_destroy_block,
  safe_not_equal,
  set_style,
  space,
  text,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots
} from "./chunk-DCE4O3CF.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-V6TY7KAL.js";

// node_modules/svelte-virtual/dist/Grid.svelte
var file = "node_modules/svelte-virtual/dist/Grid.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  const constants_0 = (
    /*getItemStyle*/
    child_ctx[9](
      /*index*/
      child_ctx[31]
    )
  );
  child_ctx[32] = constants_0;
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  index: dirty[0] & /*indexes*/
  128,
  scrollPosition: dirty[0] & /*scrollPosition*/
  8,
  style: dirty[0] & /*indexes*/
  128
});
var get_item_slot_context = (ctx) => ({
  index: (
    /*index*/
    ctx[31]
  ),
  scrollPosition: (
    /*scrollPosition*/
    ctx[3]
  ),
  style: (
    /*style*/
    ctx[32]
  )
});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let div_resize_listener;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[25].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (header_slot) header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (header_slot) header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[26].call(div)
      ));
      add_location(div, file, 102, 2, 3124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (header_slot) {
        header_slot.m(div, null);
      }
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[26].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (header_slot) header_slot.d(detaching);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(102:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Missing template");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Missing template");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(112:54) Missing template",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let current;
  const item_slot_template = (
    /*#slots*/
    ctx[25].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_item_slot_context
  );
  const item_slot_or_fallback = item_slot || fallback_block(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (item_slot_or_fallback) item_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (item_slot_or_fallback) item_slot_or_fallback.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*$$scope, indexes, scrollPosition*/
        16777352)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(109:2) {#each indexes as index (index)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1_resize_listener;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[11].header && create_if_block(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*indexes*/
    ctx[7]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[31]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const footer_slot_template = (
    /*#slots*/
    ctx[25].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (footer_slot) footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (footer_slot) footer_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div0,
        "height",
        /*innerHeight*/
        ctx[8] + "px"
      );
      set_style(div0, "width", "100%");
      add_location(div0, file, 107, 1, 3212);
      set_style(div1, "position", "relative");
      set_style(div1, "overflow", "auto");
      set_style(
        div1,
        "height",
        /*height*/
        ctx[0] + "px"
      );
      set_style(
        div1,
        "width",
        /*width*/
        ctx[1]
      );
      add_render_callback(() => (
        /*div1_elementresize_handler*/
        ctx[28].call(div1)
      ));
      add_location(div1, file, 94, 0, 2928);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div1, t1);
      if (footer_slot) {
        footer_slot.m(div1, null);
      }
      ctx[27](div1);
      div1_resize_listener = add_iframe_resize_listener(
        div1,
        /*div1_elementresize_handler*/
        ctx[28].bind(div1)
      );
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "scroll",
          /*onScroll*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[11].header
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*$$scope, indexes, scrollPosition, getItemStyle*/
      16777864) {
        each_value = ensure_array_like_dev(
          /*indexes*/
          ctx2[7]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[0] & /*innerHeight*/
      256) {
        set_style(
          div0,
          "height",
          /*innerHeight*/
          ctx2[8] + "px"
        );
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*height*/
      1) {
        set_style(
          div1,
          "height",
          /*height*/
          ctx2[0] + "px"
        );
      }
      if (!current || dirty[0] & /*width*/
      2) {
        set_style(
          div1,
          "width",
          /*width*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (footer_slot) footer_slot.d(detaching);
      ctx[27](null);
      div1_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let columnCount;
  let innerHeight;
  let overScanColumn;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["header", "item", "footer"]);
  const $$slots = compute_slots(slots);
  let { itemCount } = $$props;
  let { itemHeight } = $$props;
  let { itemWidth } = $$props;
  let { height } = $$props;
  let { width = "100%" } = $$props;
  let { overScan = 1 } = $$props;
  let { marginLeft = 0 } = $$props;
  let { marginTop = 0 } = $$props;
  let { scrollToIndex = void 0 } = $$props;
  let { scrollToPosition = void 0 } = $$props;
  let { scrollToBehavior = "auto" } = $$props;
  let grid;
  let scrollPosition = 0;
  let headerHeight = 0;
  let offsetWidth = 0;
  let clientWidth = 0;
  let indexes = [];
  const scrollTo = {
    index: (index) => {
      $$invalidate(12, scrollToIndex = index);
    },
    position: (position) => {
      $$invalidate(13, scrollToPosition = position);
    }
  };
  const roundTo = (x, multiple, type = "ceil") => {
    if (type === "ceil") {
      return Math.ceil(x / multiple) * multiple;
    }
    return ~~(x / multiple) * multiple;
  };
  const getIndexes = (itemCount2, itemHeight2, height2, columnCount2, overScanColumn2, scrollPosition2) => {
    const indexes2 = [];
    const startIndexTemp = roundTo(scrollPosition2 / itemHeight2 * columnCount2, columnCount2, "floor");
    const startIndexOverScan = startIndexTemp > overScanColumn2 ? startIndexTemp - overScanColumn2 : 0;
    const startIndex = startIndexTemp > 0 && startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
    const endIndexTemp = Math.min(itemCount2, roundTo((scrollPosition2 + height2) / itemHeight2 * columnCount2, columnCount2));
    const endIndexOverScan = endIndexTemp + overScanColumn2;
    const endIndex = endIndexOverScan < itemCount2 ? endIndexOverScan : itemCount2;
    for (let i = 0; i < endIndex - startIndex; i++) indexes2.push(i + startIndex);
    return indexes2;
  };
  const getItemStyle = (index) => `position: absolute; transform: translate3d(${index % columnCount * itemWidth + marginLeft}px, ${(Math.ceil((index + 1) / columnCount) - 1) * itemHeight + marginTop}px, 0px); height: ${itemHeight}px; width: ${itemWidth}px; will-change: transform;`;
  const onScroll = ({ currentTarget }) => {
    if (scrollToIndex === void 0 && scrollToPosition === void 0) {
      $$invalidate(3, scrollPosition = Math.max(0, currentTarget.scrollTop - headerHeight));
    }
  };
  $$self.$$.on_mount.push(function() {
    if (itemCount === void 0 && !("itemCount" in $$props || $$self.$$.bound[$$self.$$.props["itemCount"]])) {
      console.warn("<Grid> was created without expected prop 'itemCount'");
    }
    if (itemHeight === void 0 && !("itemHeight" in $$props || $$self.$$.bound[$$self.$$.props["itemHeight"]])) {
      console.warn("<Grid> was created without expected prop 'itemHeight'");
    }
    if (itemWidth === void 0 && !("itemWidth" in $$props || $$self.$$.bound[$$self.$$.props["itemWidth"]])) {
      console.warn("<Grid> was created without expected prop 'itemWidth'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Grid> was created without expected prop 'height'");
    }
  });
  const writable_props = [
    "itemCount",
    "itemHeight",
    "itemWidth",
    "height",
    "width",
    "overScan",
    "marginLeft",
    "marginTop",
    "scrollToIndex",
    "scrollToPosition",
    "scrollToBehavior"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Grid> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    headerHeight = this.offsetHeight;
    $$invalidate(4, headerHeight);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      grid = $$value;
      $$invalidate(2, grid);
    });
  }
  function div1_elementresize_handler() {
    offsetWidth = this.offsetWidth;
    clientWidth = this.clientWidth;
    $$invalidate(5, offsetWidth);
    $$invalidate(6, clientWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("itemCount" in $$props2) $$invalidate(14, itemCount = $$props2.itemCount);
    if ("itemHeight" in $$props2) $$invalidate(15, itemHeight = $$props2.itemHeight);
    if ("itemWidth" in $$props2) $$invalidate(16, itemWidth = $$props2.itemWidth);
    if ("height" in $$props2) $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2) $$invalidate(1, width = $$props2.width);
    if ("overScan" in $$props2) $$invalidate(17, overScan = $$props2.overScan);
    if ("marginLeft" in $$props2) $$invalidate(18, marginLeft = $$props2.marginLeft);
    if ("marginTop" in $$props2) $$invalidate(19, marginTop = $$props2.marginTop);
    if ("scrollToIndex" in $$props2) $$invalidate(12, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToPosition" in $$props2) $$invalidate(13, scrollToPosition = $$props2.scrollToPosition);
    if ("scrollToBehavior" in $$props2) $$invalidate(20, scrollToBehavior = $$props2.scrollToBehavior);
    if ("$$scope" in $$props2) $$invalidate(24, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    itemCount,
    itemHeight,
    itemWidth,
    height,
    width,
    overScan,
    marginLeft,
    marginTop,
    scrollToIndex,
    scrollToPosition,
    scrollToBehavior,
    grid,
    scrollPosition,
    headerHeight,
    offsetWidth,
    clientWidth,
    indexes,
    scrollTo,
    roundTo,
    getIndexes,
    getItemStyle,
    onScroll,
    overScanColumn,
    columnCount,
    innerHeight
  });
  $$self.$inject_state = ($$props2) => {
    if ("itemCount" in $$props2) $$invalidate(14, itemCount = $$props2.itemCount);
    if ("itemHeight" in $$props2) $$invalidate(15, itemHeight = $$props2.itemHeight);
    if ("itemWidth" in $$props2) $$invalidate(16, itemWidth = $$props2.itemWidth);
    if ("height" in $$props2) $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2) $$invalidate(1, width = $$props2.width);
    if ("overScan" in $$props2) $$invalidate(17, overScan = $$props2.overScan);
    if ("marginLeft" in $$props2) $$invalidate(18, marginLeft = $$props2.marginLeft);
    if ("marginTop" in $$props2) $$invalidate(19, marginTop = $$props2.marginTop);
    if ("scrollToIndex" in $$props2) $$invalidate(12, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToPosition" in $$props2) $$invalidate(13, scrollToPosition = $$props2.scrollToPosition);
    if ("scrollToBehavior" in $$props2) $$invalidate(20, scrollToBehavior = $$props2.scrollToBehavior);
    if ("grid" in $$props2) $$invalidate(2, grid = $$props2.grid);
    if ("scrollPosition" in $$props2) $$invalidate(3, scrollPosition = $$props2.scrollPosition);
    if ("headerHeight" in $$props2) $$invalidate(4, headerHeight = $$props2.headerHeight);
    if ("offsetWidth" in $$props2) $$invalidate(5, offsetWidth = $$props2.offsetWidth);
    if ("clientWidth" in $$props2) $$invalidate(6, clientWidth = $$props2.clientWidth);
    if ("indexes" in $$props2) $$invalidate(7, indexes = $$props2.indexes);
    if ("overScanColumn" in $$props2) $$invalidate(22, overScanColumn = $$props2.overScanColumn);
    if ("columnCount" in $$props2) $$invalidate(23, columnCount = $$props2.columnCount);
    if ("innerHeight" in $$props2) $$invalidate(8, innerHeight = $$props2.innerHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*offsetWidth, marginLeft, clientWidth, itemWidth*/
    327776) {
      $: $$invalidate(23, columnCount = Math.max(~~((offsetWidth - marginLeft - (offsetWidth - clientWidth)) / itemWidth), 1));
    }
    if ($$self.$$.dirty[0] & /*grid, scrollToIndex, columnCount, itemHeight, headerHeight, marginTop, scrollToBehavior*/
    9998356) {
      $: if (grid && scrollToIndex !== void 0) {
        grid.scrollTo({
          top: (Math.ceil((scrollToIndex + 1) / columnCount) - 1) * itemHeight + headerHeight + marginTop,
          behavior: scrollToBehavior
        });
        $$invalidate(12, scrollToIndex = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*grid, scrollToPosition, headerHeight, scrollToBehavior*/
    1056788) {
      $: if (grid && scrollToPosition !== void 0) {
        grid.scrollTo({
          top: scrollToPosition + headerHeight,
          behavior: scrollToBehavior
        });
        $$invalidate(13, scrollToPosition = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*itemCount, columnCount, itemHeight, height*/
    8437761) {
      $: $$invalidate(8, innerHeight = Math.max(roundTo(itemCount, columnCount) * itemHeight / columnCount, height));
    }
    if ($$self.$$.dirty[0] & /*columnCount, overScan*/
    8519680) {
      $: $$invalidate(22, overScanColumn = columnCount * overScan);
    }
    if ($$self.$$.dirty[0] & /*offsetWidth, itemCount, itemHeight, height, columnCount, overScanColumn, scrollPosition*/
    12632105) {
      $: if (offsetWidth) {
        $$invalidate(7, indexes = getIndexes(itemCount, itemHeight, height, columnCount, overScanColumn, scrollPosition));
      }
    }
  };
  return [
    height,
    width,
    grid,
    scrollPosition,
    headerHeight,
    offsetWidth,
    clientWidth,
    indexes,
    innerHeight,
    getItemStyle,
    onScroll,
    $$slots,
    scrollToIndex,
    scrollToPosition,
    itemCount,
    itemHeight,
    itemWidth,
    overScan,
    marginLeft,
    marginTop,
    scrollToBehavior,
    scrollTo,
    overScanColumn,
    columnCount,
    $$scope,
    slots,
    div_elementresize_handler,
    div1_binding,
    div1_elementresize_handler
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        itemCount: 14,
        itemHeight: 15,
        itemWidth: 16,
        height: 0,
        width: 1,
        overScan: 17,
        marginLeft: 18,
        marginTop: 19,
        scrollToIndex: 12,
        scrollToPosition: 13,
        scrollToBehavior: 20,
        scrollTo: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment.name
    });
  }
  get itemCount() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemCount(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemHeight() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemHeight(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemWidth() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemWidth(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overScan() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overScan(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginLeft() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginLeft(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginTop() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginTop(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToIndex() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToIndex(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToPosition() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToPosition(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToBehavior() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToBehavior(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[21];
  }
  set scrollTo(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/svelte-virtual/dist/List.svelte
var file2 = "node_modules/svelte-virtual/dist/List.svelte";
var get_footer_slot_changes2 = (dirty) => ({});
var get_footer_slot_context2 = (ctx) => ({});
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  const constants_0 = (
    /*getItemStyle*/
    child_ctx[12](
      /*index*/
      child_ctx[33]
    )
  );
  child_ctx[34] = constants_0;
  return child_ctx;
}
var get_item_slot_changes2 = (dirty) => ({
  index: dirty[0] & /*indexes*/
  1024,
  scrollPosition: dirty[0] & /*scrollPosition*/
  8,
  style: dirty[0] & /*indexes*/
  1024
});
var get_item_slot_context2 = (ctx) => ({
  index: (
    /*index*/
    ctx[33]
  ),
  scrollPosition: (
    /*scrollPosition*/
    ctx[3]
  ),
  style: (
    /*style*/
    ctx[34]
  )
});
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_if_block2(ctx) {
  let div;
  let div_resize_listener;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[27].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_header_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (header_slot) header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (header_slot) header_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[28].call(div)
      ));
      add_location(div, file2, 92, 2, 3053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (header_slot) {
        header_slot.m(div, null);
      }
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[28].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (header_slot) header_slot.d(detaching);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(92:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Missing template");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Missing template");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(106:54) Missing template",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let first;
  let current;
  const item_slot_template = (
    /*#slots*/
    ctx[27].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_item_slot_context2
  );
  const item_slot_or_fallback = item_slot || fallback_block2(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (item_slot_or_fallback) item_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (item_slot_or_fallback) item_slot_or_fallback.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*$$scope, indexes, scrollPosition*/
        67109896)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[26]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[26],
              dirty,
              get_item_slot_changes2
            ),
            get_item_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(103:2) {#each indexes as index (index)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div1;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1_resize_listener;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[14].header && create_if_block2(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*indexes*/
    ctx[10]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[33]
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const footer_slot_template = (
    /*#slots*/
    ctx[27].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_footer_slot_context2
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (footer_slot) footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (footer_slot) footer_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div0,
        "height",
        /*isVertical*/
        ctx[9] ? `${/*innerSize*/
        ctx[11]}px` : "100%"
      );
      set_style(div0, "width", !/*isVertical*/
      ctx[9] ? `${/*innerSize*/
      ctx[11]}px` : "100%");
      add_location(div0, file2, 97, 1, 3141);
      set_style(div1, "position", "relative");
      set_style(div1, "overflow", "auto");
      set_style(
        div1,
        "height",
        /*height*/
        ctx[0] + "px"
      );
      set_style(
        div1,
        "width",
        /*width*/
        ctx[1]
      );
      add_render_callback(() => (
        /*div1_elementresize_handler*/
        ctx[30].call(div1)
      ));
      add_location(div1, file2, 82, 0, 2817);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div1, t1);
      if (footer_slot) {
        footer_slot.m(div1, null);
      }
      ctx[29](div1);
      div1_resize_listener = add_iframe_resize_listener(
        div1,
        /*div1_elementresize_handler*/
        ctx[30].bind(div1)
      );
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div1,
          "scroll",
          /*onScroll*/
          ctx[13],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[14].header
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*$$scope, indexes, scrollPosition, getItemStyle*/
      67113992) {
        each_value = ensure_array_like_dev(
          /*indexes*/
          ctx2[10]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty[0] & /*isVertical, innerSize*/
      2560) {
        set_style(
          div0,
          "height",
          /*isVertical*/
          ctx2[9] ? `${/*innerSize*/
          ctx2[11]}px` : "100%"
        );
      }
      if (!current || dirty[0] & /*isVertical, innerSize*/
      2560) {
        set_style(div0, "width", !/*isVertical*/
        ctx2[9] ? `${/*innerSize*/
        ctx2[11]}px` : "100%");
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_footer_slot_changes2
            ),
            get_footer_slot_context2
          );
        }
      }
      if (!current || dirty[0] & /*height*/
      1) {
        set_style(
          div1,
          "height",
          /*height*/
          ctx2[0] + "px"
        );
      }
      if (!current || dirty[0] & /*width*/
      2) {
        set_style(
          div1,
          "width",
          /*width*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (footer_slot) footer_slot.d(detaching);
      ctx[29](null);
      div1_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let isVertical;
  let innerSize;
  let itemSizeInternal;
  let size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["header", "item", "footer"]);
  const $$slots = compute_slots(slots);
  let { itemCount } = $$props;
  let { itemSize } = $$props;
  let { height } = $$props;
  let { width = "100%" } = $$props;
  let { overScan = 1 } = $$props;
  let { marginLeft = 0 } = $$props;
  let { marginTop = 0 } = $$props;
  let { layout = "vertical" } = $$props;
  let { scrollToIndex = void 0 } = $$props;
  let { scrollToPosition = void 0 } = $$props;
  let { scrollToBehavior = "auto" } = $$props;
  let list;
  let scrollPosition = 0;
  let headerHeight = 0;
  let offsetHeight = 0;
  let clientHeight = 0;
  let offsetWidth = 0;
  let clientWidth = 0;
  let indexes = [];
  const scrollTo = {
    index: (index) => {
      $$invalidate(15, scrollToIndex = index);
    },
    position: (position) => {
      $$invalidate(16, scrollToPosition = position);
    }
  };
  const getIndexes = (itemCount2, itemSize2, size2, overScan2, scrollPosition2) => {
    const indexes2 = [];
    const startIndexTemp = ~~(scrollPosition2 / itemSize2);
    const startIndexOverScan = startIndexTemp > overScan2 ? startIndexTemp - overScan2 : 0;
    const startIndex = startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
    const endIndexTemp = Math.min(itemCount2, ~~((scrollPosition2 + size2) / itemSize2));
    const endIndexOverScan = endIndexTemp + overScan2;
    const endIndex = endIndexOverScan < itemCount2 ? endIndexOverScan : itemCount2;
    for (let i = 0; i < endIndex - startIndex; i++) indexes2.push(i + startIndex);
    return indexes2;
  };
  const getItemStyle = (index) => {
    const ixis = index * itemSize;
    return `position: absolute; transform: translate3d(${isVertical ? `${marginLeft}px, ${ixis + marginTop}px` : `${ixis + marginLeft}px, ${marginTop}px`}, 0px); ${itemSizeInternal} will-change: transform;`;
  };
  const onScroll = ({ currentTarget }) => {
    if (scrollToIndex === void 0 && scrollToPosition === void 0) {
      if (isVertical) {
        $$invalidate(3, scrollPosition = Math.max(0, currentTarget.scrollTop - headerHeight));
      } else {
        $$invalidate(3, scrollPosition = currentTarget.scrollLeft);
      }
    }
  };
  $$self.$$.on_mount.push(function() {
    if (itemCount === void 0 && !("itemCount" in $$props || $$self.$$.bound[$$self.$$.props["itemCount"]])) {
      console.warn("<List> was created without expected prop 'itemCount'");
    }
    if (itemSize === void 0 && !("itemSize" in $$props || $$self.$$.bound[$$self.$$.props["itemSize"]])) {
      console.warn("<List> was created without expected prop 'itemSize'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<List> was created without expected prop 'height'");
    }
  });
  const writable_props = [
    "itemCount",
    "itemSize",
    "height",
    "width",
    "overScan",
    "marginLeft",
    "marginTop",
    "layout",
    "scrollToIndex",
    "scrollToPosition",
    "scrollToBehavior"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<List> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    headerHeight = this.offsetHeight;
    $$invalidate(4, headerHeight);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  function div1_elementresize_handler() {
    offsetHeight = this.offsetHeight;
    clientHeight = this.clientHeight;
    offsetWidth = this.offsetWidth;
    clientWidth = this.clientWidth;
    $$invalidate(5, offsetHeight);
    $$invalidate(6, clientHeight);
    $$invalidate(7, offsetWidth);
    $$invalidate(8, clientWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("itemCount" in $$props2) $$invalidate(17, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2) $$invalidate(18, itemSize = $$props2.itemSize);
    if ("height" in $$props2) $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2) $$invalidate(1, width = $$props2.width);
    if ("overScan" in $$props2) $$invalidate(19, overScan = $$props2.overScan);
    if ("marginLeft" in $$props2) $$invalidate(20, marginLeft = $$props2.marginLeft);
    if ("marginTop" in $$props2) $$invalidate(21, marginTop = $$props2.marginTop);
    if ("layout" in $$props2) $$invalidate(22, layout = $$props2.layout);
    if ("scrollToIndex" in $$props2) $$invalidate(15, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToPosition" in $$props2) $$invalidate(16, scrollToPosition = $$props2.scrollToPosition);
    if ("scrollToBehavior" in $$props2) $$invalidate(23, scrollToBehavior = $$props2.scrollToBehavior);
    if ("$$scope" in $$props2) $$invalidate(26, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    itemCount,
    itemSize,
    height,
    width,
    overScan,
    marginLeft,
    marginTop,
    layout,
    scrollToIndex,
    scrollToPosition,
    scrollToBehavior,
    list,
    scrollPosition,
    headerHeight,
    offsetHeight,
    clientHeight,
    offsetWidth,
    clientWidth,
    indexes,
    scrollTo,
    getIndexes,
    getItemStyle,
    onScroll,
    size,
    isVertical,
    itemSizeInternal,
    innerSize
  });
  $$self.$inject_state = ($$props2) => {
    if ("itemCount" in $$props2) $$invalidate(17, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2) $$invalidate(18, itemSize = $$props2.itemSize);
    if ("height" in $$props2) $$invalidate(0, height = $$props2.height);
    if ("width" in $$props2) $$invalidate(1, width = $$props2.width);
    if ("overScan" in $$props2) $$invalidate(19, overScan = $$props2.overScan);
    if ("marginLeft" in $$props2) $$invalidate(20, marginLeft = $$props2.marginLeft);
    if ("marginTop" in $$props2) $$invalidate(21, marginTop = $$props2.marginTop);
    if ("layout" in $$props2) $$invalidate(22, layout = $$props2.layout);
    if ("scrollToIndex" in $$props2) $$invalidate(15, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToPosition" in $$props2) $$invalidate(16, scrollToPosition = $$props2.scrollToPosition);
    if ("scrollToBehavior" in $$props2) $$invalidate(23, scrollToBehavior = $$props2.scrollToBehavior);
    if ("list" in $$props2) $$invalidate(2, list = $$props2.list);
    if ("scrollPosition" in $$props2) $$invalidate(3, scrollPosition = $$props2.scrollPosition);
    if ("headerHeight" in $$props2) $$invalidate(4, headerHeight = $$props2.headerHeight);
    if ("offsetHeight" in $$props2) $$invalidate(5, offsetHeight = $$props2.offsetHeight);
    if ("clientHeight" in $$props2) $$invalidate(6, clientHeight = $$props2.clientHeight);
    if ("offsetWidth" in $$props2) $$invalidate(7, offsetWidth = $$props2.offsetWidth);
    if ("clientWidth" in $$props2) $$invalidate(8, clientWidth = $$props2.clientWidth);
    if ("indexes" in $$props2) $$invalidate(10, indexes = $$props2.indexes);
    if ("size" in $$props2) $$invalidate(25, size = $$props2.size);
    if ("isVertical" in $$props2) $$invalidate(9, isVertical = $$props2.isVertical);
    if ("itemSizeInternal" in $$props2) itemSizeInternal = $$props2.itemSizeInternal;
    if ("innerSize" in $$props2) $$invalidate(11, innerSize = $$props2.innerSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*layout*/
    4194304) {
      $: $$invalidate(9, isVertical = layout === "vertical");
    }
    if ($$self.$$.dirty[0] & /*list, scrollToIndex, isVertical, itemSize, headerHeight, marginTop, marginLeft, scrollToBehavior*/
    11829780) {
      $: if (list && scrollToIndex !== void 0) {
        list.scrollTo({
          [isVertical ? "top" : "left"]: scrollToIndex * itemSize + headerHeight + (isVertical ? marginTop : marginLeft),
          behavior: scrollToBehavior
        });
        $$invalidate(15, scrollToIndex = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*list, scrollToPosition, isVertical, headerHeight, scrollToBehavior*/
    8454676) {
      $: if (list && scrollToPosition !== void 0) {
        list.scrollTo({
          [isVertical ? "top" : "left"]: scrollToPosition + headerHeight,
          behavior: scrollToBehavior
        });
        $$invalidate(16, scrollToPosition = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*isVertical, offsetHeight, offsetWidth*/
    672) {
      $: $$invalidate(25, size = isVertical ? offsetHeight : offsetWidth);
    }
    if ($$self.$$.dirty[0] & /*itemCount, itemSize, size*/
    33947648) {
      $: $$invalidate(11, innerSize = Math.max(itemCount * itemSize, size));
    }
    if ($$self.$$.dirty[0] & /*isVertical, itemSize, marginLeft, clientWidth, marginTop, clientHeight*/
    3408704) {
      $: itemSizeInternal = isVertical ? `height: ${itemSize}px; width: ${marginLeft > 0 ? `${clientWidth - marginLeft}px` : "100%"};` : `height: ${marginTop > 0 ? `${clientHeight - marginTop}px` : "100%"}; width: ${itemSize}px;`;
    }
    if ($$self.$$.dirty[0] & /*offsetHeight, itemCount, itemSize, size, overScan, scrollPosition*/
    34471976) {
      $: if (offsetHeight) {
        $$invalidate(10, indexes = getIndexes(itemCount, itemSize, size, overScan, scrollPosition));
      }
    }
  };
  return [
    height,
    width,
    list,
    scrollPosition,
    headerHeight,
    offsetHeight,
    clientHeight,
    offsetWidth,
    clientWidth,
    isVertical,
    indexes,
    innerSize,
    getItemStyle,
    onScroll,
    $$slots,
    scrollToIndex,
    scrollToPosition,
    itemCount,
    itemSize,
    overScan,
    marginLeft,
    marginTop,
    layout,
    scrollToBehavior,
    scrollTo,
    size,
    $$scope,
    slots,
    div_elementresize_handler,
    div1_binding,
    div1_elementresize_handler
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        itemCount: 17,
        itemSize: 18,
        height: 0,
        width: 1,
        overScan: 19,
        marginLeft: 20,
        marginTop: 21,
        layout: 22,
        scrollToIndex: 15,
        scrollToPosition: 16,
        scrollToBehavior: 23,
        scrollTo: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment2.name
    });
  }
  get itemCount() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemCount(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemSize() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemSize(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overScan() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overScan(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginLeft() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginLeft(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginTop() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginTop(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layout(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToPosition() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToPosition(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToBehavior() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToBehavior(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[24];
  }
  set scrollTo(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;
export {
  Grid_default as Grid,
  List_default as List
};
//# sourceMappingURL=svelte-virtual.js.map
