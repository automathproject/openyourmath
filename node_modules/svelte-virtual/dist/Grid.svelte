<script>export let itemCount;
export let itemHeight;
export let itemWidth;
export let height;
export let width = "100%";
export let overScan = 1;
export let marginLeft = 0;
export let marginTop = 0;
export let scrollToIndex = void 0;
export let scrollToPosition = void 0;
export let scrollToBehavior = "auto";
let grid;
let scrollPosition = 0;
let headerHeight = 0;
let offsetWidth = 0;
let clientWidth = 0;
let indexes = [];
export const scrollTo = {
  index: (index) => {
    scrollToIndex = index;
  },
  position: (position) => {
    scrollToPosition = position;
  }
};
const roundTo = (x, multiple, type = "ceil") => {
  if (type === "ceil") {
    return Math.ceil(x / multiple) * multiple;
  }
  return ~~(x / multiple) * multiple;
};
const getIndexes = (itemCount2, itemHeight2, height2, columnCount2, overScanColumn2, scrollPosition2) => {
  const indexes2 = [];
  const startIndexTemp = roundTo(
    scrollPosition2 / itemHeight2 * columnCount2,
    columnCount2,
    "floor"
  );
  const startIndexOverScan = startIndexTemp > overScanColumn2 ? startIndexTemp - overScanColumn2 : 0;
  const startIndex = startIndexTemp > 0 && startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
  const endIndexTemp = Math.min(
    itemCount2,
    roundTo((scrollPosition2 + height2) / itemHeight2 * columnCount2, columnCount2)
  );
  const endIndexOverScan = endIndexTemp + overScanColumn2;
  const endIndex = endIndexOverScan < itemCount2 ? endIndexOverScan : itemCount2;
  for (let i = 0; i < endIndex - startIndex; i++)
    indexes2.push(i + startIndex);
  return indexes2;
};
const getItemStyle = (index) => `position: absolute; transform: translate3d(${index % columnCount * itemWidth + marginLeft}px, ${(Math.ceil((index + 1) / columnCount) - 1) * itemHeight + marginTop}px, 0px); height: ${itemHeight}px; width: ${itemWidth}px; will-change: transform;`;
const onScroll = ({ currentTarget }) => {
  if (scrollToIndex === void 0 && scrollToPosition === void 0) {
    scrollPosition = Math.max(0, currentTarget.scrollTop - headerHeight);
  }
};
$:
  if (grid && scrollToIndex !== void 0) {
    grid.scrollTo({
      top: (Math.ceil((scrollToIndex + 1) / columnCount) - 1) * itemHeight + headerHeight + marginTop,
      behavior: scrollToBehavior
    });
    scrollToIndex = void 0;
  }
$:
  if (grid && scrollToPosition !== void 0) {
    grid.scrollTo({
      top: scrollToPosition + headerHeight,
      behavior: scrollToBehavior
    });
    scrollToPosition = void 0;
  }
$:
  columnCount = Math.max(
    ~~((offsetWidth - marginLeft - (offsetWidth - clientWidth)) / itemWidth),
    1
  );
$:
  innerHeight = Math.max(roundTo(itemCount, columnCount) * itemHeight / columnCount, height);
$:
  overScanColumn = columnCount * overScan;
$:
  if (offsetWidth) {
    indexes = getIndexes(
      itemCount,
      itemHeight,
      height,
      columnCount,
      overScanColumn,
      scrollPosition
    );
  }
</script>

<div
	style="position: relative; overflow: auto; height: {height}px; width: {width};"
	on:scroll={onScroll}
	bind:this={grid}
	bind:offsetWidth
	bind:clientWidth
>
	{#if $$slots.header}
		<div bind:offsetHeight={headerHeight}>
			<slot name="header" />
		</div>
	{/if}

	<div style="height: {innerHeight}px; width: 100%;">
		{#each indexes as index (index)}
			{@const style = getItemStyle(index)}

			<slot name="item" {index} {scrollPosition} {style}>Missing template</slot>
		{/each}
	</div>

	<slot name="footer" />
</div>
