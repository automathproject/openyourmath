<script>export let itemCount;
export let itemSize;
export let height;
export let width = "100%";
export let overScan = 1;
export let marginLeft = 0;
export let marginTop = 0;
export let layout = "vertical";
export let scrollToIndex = void 0;
export let scrollToPosition = void 0;
export let scrollToBehavior = "auto";
let list;
let scrollPosition = 0;
let headerHeight = 0;
let offsetHeight = 0;
let clientHeight = 0;
let offsetWidth = 0;
let clientWidth = 0;
let indexes = [];
export const scrollTo = {
  index: (index) => {
    scrollToIndex = index;
  },
  position: (position) => {
    scrollToPosition = position;
  }
};
const getIndexes = (itemCount2, itemSize2, size2, overScan2, scrollPosition2) => {
  const indexes2 = [];
  const startIndexTemp = ~~(scrollPosition2 / itemSize2);
  const startIndexOverScan = startIndexTemp > overScan2 ? startIndexTemp - overScan2 : 0;
  const startIndex = startIndexOverScan >= 0 ? startIndexOverScan : startIndexTemp;
  const endIndexTemp = Math.min(itemCount2, ~~((scrollPosition2 + size2) / itemSize2));
  const endIndexOverScan = endIndexTemp + overScan2;
  const endIndex = endIndexOverScan < itemCount2 ? endIndexOverScan : itemCount2;
  for (let i = 0; i < endIndex - startIndex; i++)
    indexes2.push(i + startIndex);
  return indexes2;
};
const getItemStyle = (index) => {
  const ixis = index * itemSize;
  return `position: absolute; transform: translate3d(${isVertical ? `${marginLeft}px, ${ixis + marginTop}px` : `${ixis + marginLeft}px, ${marginTop}px`}, 0px); ${itemSizeInternal} will-change: transform;`;
};
const onScroll = ({ currentTarget }) => {
  if (scrollToIndex === void 0 && scrollToPosition === void 0) {
    if (isVertical) {
      scrollPosition = Math.max(0, currentTarget.scrollTop - headerHeight);
    } else {
      scrollPosition = currentTarget.scrollLeft;
    }
  }
};
$:
  if (list && scrollToIndex !== void 0) {
    list.scrollTo({
      [isVertical ? "top" : "left"]: scrollToIndex * itemSize + headerHeight + (isVertical ? marginTop : marginLeft),
      behavior: scrollToBehavior
    });
    scrollToIndex = void 0;
  }
$:
  if (list && scrollToPosition !== void 0) {
    list.scrollTo({
      [isVertical ? "top" : "left"]: scrollToPosition + headerHeight,
      behavior: scrollToBehavior
    });
    scrollToPosition = void 0;
  }
$:
  isVertical = layout === "vertical";
$:
  innerSize = Math.max(itemCount * itemSize, size);
$:
  itemSizeInternal = isVertical ? `height: ${itemSize}px; width: ${marginLeft > 0 ? `${clientWidth - marginLeft}px` : "100%"};` : `height: ${marginTop > 0 ? `${clientHeight - marginTop}px` : "100%"}; width: ${itemSize}px;`;
$:
  size = isVertical ? offsetHeight : offsetWidth;
$:
  if (offsetHeight) {
    indexes = getIndexes(itemCount, itemSize, size, overScan, scrollPosition);
  }
</script>

<div
	style="position: relative; overflow: auto; height: {height}px; width: {width};"
	on:scroll={onScroll}
	bind:this={list}
	bind:offsetHeight
	bind:clientHeight
	bind:offsetWidth
	bind:clientWidth
>
	{#if $$slots.header}
		<div bind:offsetHeight={headerHeight}>
			<slot name="header" />
		</div>
	{/if}

	<div
		style="height: {isVertical ? `${innerSize}px` : '100%'}; width: {!isVertical
			? `${innerSize}px`
			: '100%'};"
	>
		{#each indexes as index (index)}
			{@const style = getItemStyle(index)}

			<slot name="item" {index} {scrollPosition} {style}>Missing template</slot>
		{/each}
	</div>

	<slot name="footer" />
</div>
